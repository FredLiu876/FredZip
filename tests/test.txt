#include <iostream>
#include <map>
#include <string>
#include <fstream>
#include <sstream>
#include <direct.h>
#include <bitset>

using namespace std;

struct Node {

    Node *left, *right;
    string characters;

    void set(string newCharacters, Node *newLeft, Node *newRight) {
        characters = newCharacters;
        left = newLeft;
        right = newRight;
    }

    void print() {
        cout << characters << endl;
    }

    void print(string code) {
        cout << characters << " -> " << code << '\n';
    }
    
};

struct Tree {

    Node *head;

    void print(Node *startPoint, string code) {

        if (startPoint->left != nullptr) {
            print(startPoint->left, code + "0");
            print(startPoint->right, code + "1");
        } else {
            startPoint->print(code);
        }

    }

    string encode(Node *startPoint) {

        string returnString;
        if (startPoint->left != nullptr) {
            returnString = encode(startPoint->left);
            returnString += encode(startPoint->right) + "0";
        } else {
            returnString = "1" + bitset<8>(startPoint->characters[0]).to_string();
        }
        return returnString;

    }
};

struct Subtree {
    Node *data;
    Subtree *next;

    Subtree() {
        next = nullptr;
    }
};

struct SubtreeStack {
    Subtree *head;
    unsigned int size;

    SubtreeStack() {
        size = 0;
        head = nullptr;
    }

    void push(Node *node) {
        Subtree *newSubtree = new Subtree;
        newSubtree->data = node;
        if (head != nullptr) {
            newSubtree->next = head;
        }
        head = newSubtree;
        size += 1;
    }

    void pop() {
        Node *node1 = head->next->data;
        Node *node2 = head->data;
        Node *combined = new Node;
        combined->set(node1->characters+node2->characters, node1, node2);
        size -= 2;
        if (size == 0) {
            head = nullptr;
        } else {
            head = head->next->next;
        }
        push(combined);
    }

    void print(Subtree *startPoint) {
        startPoint->data->print();
        if (startPoint->next != nullptr) {
            print(startPoint->next);
        }
    }
};

int main(int argc, char *argv[]) {

    string target = argv[1];
    ifstream inputFile( target, ios_base::binary );
    string decode ((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
    inputFile.close();

    string allBits = "";
    for (unsigned int i = 0; i < decode.length(); i++) {
        if (!(decode[i] == '\r' && i+1 < decode.length() && decode[i+1] == '\n')) {
            allBits += bitset<8>(decode[i]).to_string();
        }
    }

    if (allBits.length() == 40) {
        string newFilename;
        for (unsigned char i = 0; i < target.length(); i++) {
            if (target.substr(i) == ".zip") {
                newFilename = target.substr(0,i);
            }
        }
        ofstream newFile (newFilename);

        for (unsigned int i = 0; i < bitset<32>(allBits.substr(8)).to_ulong(); i++) {
            newFile << decode[0];
        }
    }

    unsigned int numChars = bitset<32>(allBits.substr(0,32)).to_ulong();
    unsigned int charsInTree = bitset<8>(allBits.substr(32,8)).to_ulong();

    allBits = allBits.substr(40);

    SubtreeStack subtreeStack;
    unsigned int charsFound = 0;
    unsigned int bitIndex = 0;
    while (charsFound != charsInTree || subtreeStack.size != 1) {

        if (allBits[bitIndex] == '1') {
            Node *leaf = new Node;
            leaf->set(string(1, bitset<8>(allBits.substr(bitIndex+1,8)).to_ulong()), nullptr, nullptr);
            subtreeStack.push(leaf);
            bitIndex += 9;
            charsFound += 1;
        } else {
            subtreeStack.pop();
            bitIndex += 1;
        }
    }

    Tree huffman = {subtreeStack.head->data};

    allBits = allBits.substr(bitIndex);

    string newFilename;
    for (unsigned char i = 0; i < target.length(); i++) {
        if (target.substr(i) == ".zip") {
            newFilename = target.substr(0,i);
        }
    }
    ofstream newFile (newFilename);

    unsigned int charsExtracted = 0;
    Node *selectedNode = huffman.head;
    for (unsigned int i = 0; i < allBits.length(); i++) {
        
        if (allBits[i] == '0') {
            selectedNode = selectedNode->left; 
        } else {
            selectedNode = selectedNode->right;
        }

        if (selectedNode->left == nullptr) {
            newFile << selectedNode->characters;
            selectedNode = huffman.head;
            charsExtracted += 1;
        }

        if (charsExtracted == numChars) {
            break;
        }
    }

    newFile.close();
}